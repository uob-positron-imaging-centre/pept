<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>pept.tracking.trajectory_separation.trajectory_separation API documentation</title>
<meta name="description" content="The *peptml* module implements a hierarchical density-based clustering
algorithm for general Positron Emission Particle Tracking (PEPT) â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pept.tracking.trajectory_separation.trajectory_separation</code></h1>
</header>
<section id="section-intro">
<p>The <em>peptml</em> module implements a hierarchical density-based clustering
algorithm for general Positron Emission Particle Tracking (PEPT)</p>
<p>The module aims to provide general classes which can
then be used in a script file as the user sees fit. For example scripts,
look at the base of the pept library.</p>
<p>The peptml subpackage accepts any instace of the LineData base class
and can create matplotlib- or plotly-based figures.</p>
<p>PEPTanalysis requires the following packages:</p>
<ul>
<li><strong>numpy</strong></li>
<li><strong>math</strong></li>
<li><strong>matplotlib.pyplot</strong> and <strong>mpl_toolkits.mplot3d</strong> for 3D matplotlib-based plotting</li>
<li><strong>joblib</strong> for multithreaded operations (such as midpoints-finding)</li>
<li><strong>tqdm</strong> for showing progress bars</li>
<li><strong>plotly.subplots</strong> and <strong>plotly.graph_objects</strong> for plotly-based plotting</li>
<li><strong>hdbscan</strong> for clustering midpoints and centres</li>
<li><strong>time</strong> for verbose timing of operations</li>
</ul>
<p>It was successfuly used at the University of Birmingham to analyse real
Fluorine-18 tracers in air.</p>
<p>If you use this package, you should cite
the following paper: [TODO: paper signature].</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# File   : trajectory_separation.py
# License: License: GNU v3.0
# Author : Andrei Leonard Nicusan &lt;a.l.nicusan@bham.ac.uk&gt;
# Date   : 23.08.2019


&#39;&#39;&#39;The *peptml* module implements a hierarchical density-based clustering
algorithm for general Positron Emission Particle Tracking (PEPT)

The module aims to provide general classes which can
then be used in a script file as the user sees fit. For example scripts,
look at the base of the pept library.

The peptml subpackage accepts any instace of the LineData base class
and can create matplotlib- or plotly-based figures.

PEPTanalysis requires the following packages:

* **numpy**
* **math**
* **matplotlib.pyplot** and **mpl_toolkits.mplot3d** for 3D matplotlib-based plotting
* **joblib** for multithreaded operations (such as midpoints-finding)
* **tqdm** for showing progress bars
* **plotly.subplots** and **plotly.graph_objects** for plotly-based plotting
* **hdbscan** for clustering midpoints and centres
* **time** for verbose timing of operations

It was successfuly used at the University of Birmingham to analyse real
Fluorine-18 tracers in air.

If you use this package, you should cite
the following paper: [TODO: paper signature].

&#39;&#39;&#39;


import  math
import  time
import  numpy                                   as          np

from    scipy.spatial                           import      cKDTree
from    joblib                                  import      Parallel,       delayed
from    tqdm                                    import      tqdm

import  pept




def findMeanError(truePositions, foundPositions):

    tree = cKDTree(truePositions)

    meanError = 0
    meanErrorX = 0
    meanErrorY = 0
    meanErrorZ = 0
    n = 0
    for centre in foundPositions:
        d, index = tree.query(centre, k = 1,  n_jobs = -1)
        meanError += np.linalg.norm(centre - truePositions[index])

        meanErrorX += np.abs(centre[0] - truePositions[index][0])
        meanErrorY += np.abs(centre[1] - truePositions[index][1])
        meanErrorZ += np.abs(centre[2] - truePositions[index][2])

        n += 1

    meanError /= n

    meanErrorX /= n
    meanErrorY /= n
    meanErrorZ /= n

    return [meanError, meanErrorX, meanErrorY, meanErrorZ]




class TrajectorySeparation:

    def __init__(self,
                 centres,
                 points_to_check = 25,
                 max_distance = 20,
                 max_cluster_size_diff = 500,
                 points_cluster_size = 50):

        # centres row: [time, x, y, z, clusterSize]
        # Make sure the trajectory is memory-contiguous for efficient
        # KDTree partitioning
        self.centres = np.ascontiguousarray(centres)
        self.points_to_check = points_to_check
        self.max_distance = max_distance
        self.max_cluster_size_diff = max_cluster_size_diff
        self.points_cluster_size = points_cluster_size

        # For every point in centres, save a set of the trajectory
        # indices of the trajectories that they are part of
        #   eg. centres[2] is part of trajectories 0 and 1 =&gt;
        #   trajectory_indices[2] = {0, 1}
        # Initialise a vector of empty sets of size len(centres)
        self.trajectory_indices = np.array([ set() for i in range(len(self.centres)) ])

        # For every trajectory found, save a list of the indices of
        # the centres that are part of that trajectory
        #   eg. trajectory 1 is comprised of centres 3, 5 and 8 =&gt;
        #   centresIndices[1] = [3, 5, 8]
        self.centres_indices = [[]]

        # Maximum trajectory index
        self.max_index = 0


    def find_trajectories(self):

        for i, current_point in enumerate(self.centres):

            if i == 0:
                # Add the first point to trajectory 0
                self.trajectory_indices[0].add(self.max_index)
                self.centres_indices[self.max_index].append(0)
                self.max_index += 1
                continue

            # Search for the closest previous pointsToCheck points
            # within a given maxDistance
            start_index = i - self.points_to_check
            end_index = i

            if start_index &lt; 0:
                start_index = 0

            # Construct a KDTree from the x, y, z (1:4) of the
            # selected points. Get the indices for all the points within
            # maxDistance of the currentPoint
            tree = cKDTree(self.centres[start_index:end_index, 1:4])
            closest_indices = tree.query_ball_point(current_point[1:4],
                                                    self.max_distance,
                                                    n_jobs = -1)
            closest_indices = np.array(closest_indices) + start_index

            # If no point was found, it is a new trajectory. Continue
            if len(closest_indices) == 0:
                self.trajectory_indices[i].add(self.max_index)
                self.centres_indices.append([i])
                self.max_index += 1
                continue

            # For every close point found, search for all the trajectory indices
            #   - If all trajectory indices sets are equal and of a single value
            #   then currentPoint is part of the same trajectory
            #   - If all trajectory indices sets are equal, but of more values,
            #   then currentPoint diverged from an intersection of trajectories
            #   and is part of a single trajectory =&gt; separate it
            #
            #   - If every pair of trajectory indices sets is not disjoint, then
            #   currentPoint is only one of them
            #   - If there exists a pair of trajectory indices sets that is
            #   disjoint, then currentPoint is part of all of them

            # Select the trajectories of all the points that were found
            # to be the closest
            closest_trajectories = self.trajectory_indices[closest_indices]
            #print(&#34;closestTrajectories:&#34;)
            #print(closestTrajectories)

            # If all the closest points are part of the same trajectory
            # (just one!), then the currentPoint is part of it too
            if (np.all(closest_trajectories == closest_trajectories[0]) and
                len(closest_trajectories[0]) == 1):

                self.trajectory_indices[i] = closest_trajectories[0]
                self.centres_indices[ next(iter(closest_trajectories[0])) ].append(i)
                continue

            # Otherwise, check the points based on their cluster size
            else:
                # Create a list of all the trajectories that were found to
                # intersect
                #print(&#39;\nIntersection:&#39;)
                closest_traj_indices = list( set().union(*closest_trajectories) )

                #print(&#34;ClosestTrajIndices:&#34;)
                #print(closestTrajIndices)

                # For each close trajectory, calculate the mean cluster size
                # of the last points_cluster_size points

                # Keep track of the mean cluster size that is the closest to
                # the currentPoint&#39;s clusterSize
                current_cluster_size = current_point[4]
                #print(&#34;currentClusterSize = {}&#34;.format(currentClusterSize))
                closest_traj_index = -1
                cluster_size_diff = self.max_cluster_size_diff

                for traj_index in closest_traj_indices:
                    #print(&#34;trajIndex = {}&#34;.format(trajIndex))

                    traj_centres = self.centres[ self.centres_indices[traj_index] ]
                    #print(&#34;trajCentres:&#34;)
                    #print(trajCentres)
                    mean_cluster_size = traj_centres[-self.points_cluster_size:][:, 4].mean()
                    #print(&#34;meanClusterSize = {}&#34;.format(meanClusterSize))
                    #print(&#34;clusterSizeDiff = {}&#34;.format(clusterSizeDiff))
                    #print(&#34;abs diff = {}&#34;.format(np.abs( currentClusterSize - meanClusterSize )))
                    if np.abs( current_cluster_size - mean_cluster_size ) &lt; cluster_size_diff:
                        closest_traj_index = traj_index
                        cluster_size_diff = np.abs( current_cluster_size - mean_cluster_size )

                if closest_traj_index == -1:
                    #self.trajectoryIndices[i] = set(closestTrajIndices)
                    #for trajIndex in closestTrajIndices:
                    #    self.centresIndices[trajIndex].append(i)

                    print(&#34;\n**** -1 ****\n&#34;)
                    break
                else:
                    #print(&#34;ClosestTrajIndex found = {}&#34;.format(closestTrajIndex))
                    self.trajectory_indices[i] = set([closest_traj_index])
                    self.centres_indices[closest_traj_index].append(i)

        individual_trajectories = []
        for traj_centres in self.centres_indices:
            individual_traj = pept.PointData(self.centres[traj_centres],
                                             sample_size = 0,
                                             overlap = 0,
                                             verbose = False)
            individual_trajectories.append(individual_traj)

        return individual_trajectories



        &#39;&#39;&#39;
            # If the current point is not part of any trajectory, assign it
            # the maxIndex and increment it
            if len(self.trajectoryIndices[i]) == 0:
                self.trajectoryIndices[i].append(self.maxIndex)
                self.maxIndex += 1

            print(self.trajectoryIndices[i])
            print(self.maxIndex)

            # Construct a KDTree from the numberOfPoints in front of
            # the current point
            tree = cKDTree(self.trajectory[(i + 1):(i + self.numberOfPoints + 2)][1:4])

            # For every trajectory that the current point is part of,
            # find the closest points in front of it
            numberOfIntersections = len(self.trajectoryIndices[i])
            dist, nextPointsIndices = tree.query(currentPoint, k=numberOfIntersections, distance_upper_bound=self.maxDistance, n_jobs=-1)

            print(nextPointsIndices)

            # If the current point is part of more trajectories,
            # an intersection happened. Call subroutine to part
            # the trajectories
            if numberOfIntersections &gt; 1:
                for j in range(0, len(self.trajectoryIndices[i])):
                    trajIndex = self.trajectoryIndices[i][j]
                    self.trajectoryIndices[i + 1 + nextPointsIndices[j]].append(trajIndex)

            else:
                self.trajectoryIndices[i + 1 + nextPointsIndices].append(self.trajectoryIndices[i][0])

            print(self.trajectoryIndices)
        &#39;&#39;&#39;


    def getTrajectories(self):

        self.individualTrajectories = []
        for trajCentres in self.centresIndices:
            self.individualTrajectories.append(self.centres[trajCentres])

        self.individualTrajectories = np.array(self.individualTrajectories)
        return self.individualTrajectories

        &#39;&#39;&#39;
        self.individualTrajectories = [ [] for i in range(0, self.maxIndex + 1) ]
        for i in range(0, len(self.trajectoryIndices)):
            for trajIndex in self.trajectoryIndices[i]:
                self.individualTrajectories[trajIndex].append(self.centres[i])

        self.individualTrajectories = np.array(self.individualTrajectories)
        for i in range(len(self.individualTrajectories)):
            if len(self.individualTrajectories[i]) &gt; 0:
                self.individualTrajectories[i] = np.vstack(self.individualTrajectories[i])
        return self.individualTrajectories
        &#39;&#39;&#39;


    def plotTrajectoriesAltAxes(self, ax):
        trajectories = self.getTrajectories()
        for traj in trajectories:
            if len(traj) &gt; 0:
                ax.scatter(traj[:, 3], traj[:, 1], traj[:, 2], marker=&#39;D&#39;, s=10)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pept.tracking.trajectory_separation.trajectory_separation.findMeanError"><code class="name flex">
<span>def <span class="ident">findMeanError</span></span>(<span>truePositions, foundPositions)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def findMeanError(truePositions, foundPositions):

    tree = cKDTree(truePositions)

    meanError = 0
    meanErrorX = 0
    meanErrorY = 0
    meanErrorZ = 0
    n = 0
    for centre in foundPositions:
        d, index = tree.query(centre, k = 1,  n_jobs = -1)
        meanError += np.linalg.norm(centre - truePositions[index])

        meanErrorX += np.abs(centre[0] - truePositions[index][0])
        meanErrorY += np.abs(centre[1] - truePositions[index][1])
        meanErrorZ += np.abs(centre[2] - truePositions[index][2])

        n += 1

    meanError /= n

    meanErrorX /= n
    meanErrorY /= n
    meanErrorZ /= n

    return [meanError, meanErrorX, meanErrorY, meanErrorZ]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pept.tracking.trajectory_separation.trajectory_separation.TrajectorySeparation"><code class="flex name class">
<span>class <span class="ident">TrajectorySeparation</span></span>
<span>(</span><span>centres, points_to_check=25, max_distance=20, max_cluster_size_diff=500, points_cluster_size=50)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class TrajectorySeparation:

    def __init__(self,
                 centres,
                 points_to_check = 25,
                 max_distance = 20,
                 max_cluster_size_diff = 500,
                 points_cluster_size = 50):

        # centres row: [time, x, y, z, clusterSize]
        # Make sure the trajectory is memory-contiguous for efficient
        # KDTree partitioning
        self.centres = np.ascontiguousarray(centres)
        self.points_to_check = points_to_check
        self.max_distance = max_distance
        self.max_cluster_size_diff = max_cluster_size_diff
        self.points_cluster_size = points_cluster_size

        # For every point in centres, save a set of the trajectory
        # indices of the trajectories that they are part of
        #   eg. centres[2] is part of trajectories 0 and 1 =&gt;
        #   trajectory_indices[2] = {0, 1}
        # Initialise a vector of empty sets of size len(centres)
        self.trajectory_indices = np.array([ set() for i in range(len(self.centres)) ])

        # For every trajectory found, save a list of the indices of
        # the centres that are part of that trajectory
        #   eg. trajectory 1 is comprised of centres 3, 5 and 8 =&gt;
        #   centresIndices[1] = [3, 5, 8]
        self.centres_indices = [[]]

        # Maximum trajectory index
        self.max_index = 0


    def find_trajectories(self):

        for i, current_point in enumerate(self.centres):

            if i == 0:
                # Add the first point to trajectory 0
                self.trajectory_indices[0].add(self.max_index)
                self.centres_indices[self.max_index].append(0)
                self.max_index += 1
                continue

            # Search for the closest previous pointsToCheck points
            # within a given maxDistance
            start_index = i - self.points_to_check
            end_index = i

            if start_index &lt; 0:
                start_index = 0

            # Construct a KDTree from the x, y, z (1:4) of the
            # selected points. Get the indices for all the points within
            # maxDistance of the currentPoint
            tree = cKDTree(self.centres[start_index:end_index, 1:4])
            closest_indices = tree.query_ball_point(current_point[1:4],
                                                    self.max_distance,
                                                    n_jobs = -1)
            closest_indices = np.array(closest_indices) + start_index

            # If no point was found, it is a new trajectory. Continue
            if len(closest_indices) == 0:
                self.trajectory_indices[i].add(self.max_index)
                self.centres_indices.append([i])
                self.max_index += 1
                continue

            # For every close point found, search for all the trajectory indices
            #   - If all trajectory indices sets are equal and of a single value
            #   then currentPoint is part of the same trajectory
            #   - If all trajectory indices sets are equal, but of more values,
            #   then currentPoint diverged from an intersection of trajectories
            #   and is part of a single trajectory =&gt; separate it
            #
            #   - If every pair of trajectory indices sets is not disjoint, then
            #   currentPoint is only one of them
            #   - If there exists a pair of trajectory indices sets that is
            #   disjoint, then currentPoint is part of all of them

            # Select the trajectories of all the points that were found
            # to be the closest
            closest_trajectories = self.trajectory_indices[closest_indices]
            #print(&#34;closestTrajectories:&#34;)
            #print(closestTrajectories)

            # If all the closest points are part of the same trajectory
            # (just one!), then the currentPoint is part of it too
            if (np.all(closest_trajectories == closest_trajectories[0]) and
                len(closest_trajectories[0]) == 1):

                self.trajectory_indices[i] = closest_trajectories[0]
                self.centres_indices[ next(iter(closest_trajectories[0])) ].append(i)
                continue

            # Otherwise, check the points based on their cluster size
            else:
                # Create a list of all the trajectories that were found to
                # intersect
                #print(&#39;\nIntersection:&#39;)
                closest_traj_indices = list( set().union(*closest_trajectories) )

                #print(&#34;ClosestTrajIndices:&#34;)
                #print(closestTrajIndices)

                # For each close trajectory, calculate the mean cluster size
                # of the last points_cluster_size points

                # Keep track of the mean cluster size that is the closest to
                # the currentPoint&#39;s clusterSize
                current_cluster_size = current_point[4]
                #print(&#34;currentClusterSize = {}&#34;.format(currentClusterSize))
                closest_traj_index = -1
                cluster_size_diff = self.max_cluster_size_diff

                for traj_index in closest_traj_indices:
                    #print(&#34;trajIndex = {}&#34;.format(trajIndex))

                    traj_centres = self.centres[ self.centres_indices[traj_index] ]
                    #print(&#34;trajCentres:&#34;)
                    #print(trajCentres)
                    mean_cluster_size = traj_centres[-self.points_cluster_size:][:, 4].mean()
                    #print(&#34;meanClusterSize = {}&#34;.format(meanClusterSize))
                    #print(&#34;clusterSizeDiff = {}&#34;.format(clusterSizeDiff))
                    #print(&#34;abs diff = {}&#34;.format(np.abs( currentClusterSize - meanClusterSize )))
                    if np.abs( current_cluster_size - mean_cluster_size ) &lt; cluster_size_diff:
                        closest_traj_index = traj_index
                        cluster_size_diff = np.abs( current_cluster_size - mean_cluster_size )

                if closest_traj_index == -1:
                    #self.trajectoryIndices[i] = set(closestTrajIndices)
                    #for trajIndex in closestTrajIndices:
                    #    self.centresIndices[trajIndex].append(i)

                    print(&#34;\n**** -1 ****\n&#34;)
                    break
                else:
                    #print(&#34;ClosestTrajIndex found = {}&#34;.format(closestTrajIndex))
                    self.trajectory_indices[i] = set([closest_traj_index])
                    self.centres_indices[closest_traj_index].append(i)

        individual_trajectories = []
        for traj_centres in self.centres_indices:
            individual_traj = pept.PointData(self.centres[traj_centres],
                                             sample_size = 0,
                                             overlap = 0,
                                             verbose = False)
            individual_trajectories.append(individual_traj)

        return individual_trajectories



        &#39;&#39;&#39;
            # If the current point is not part of any trajectory, assign it
            # the maxIndex and increment it
            if len(self.trajectoryIndices[i]) == 0:
                self.trajectoryIndices[i].append(self.maxIndex)
                self.maxIndex += 1

            print(self.trajectoryIndices[i])
            print(self.maxIndex)

            # Construct a KDTree from the numberOfPoints in front of
            # the current point
            tree = cKDTree(self.trajectory[(i + 1):(i + self.numberOfPoints + 2)][1:4])

            # For every trajectory that the current point is part of,
            # find the closest points in front of it
            numberOfIntersections = len(self.trajectoryIndices[i])
            dist, nextPointsIndices = tree.query(currentPoint, k=numberOfIntersections, distance_upper_bound=self.maxDistance, n_jobs=-1)

            print(nextPointsIndices)

            # If the current point is part of more trajectories,
            # an intersection happened. Call subroutine to part
            # the trajectories
            if numberOfIntersections &gt; 1:
                for j in range(0, len(self.trajectoryIndices[i])):
                    trajIndex = self.trajectoryIndices[i][j]
                    self.trajectoryIndices[i + 1 + nextPointsIndices[j]].append(trajIndex)

            else:
                self.trajectoryIndices[i + 1 + nextPointsIndices].append(self.trajectoryIndices[i][0])

            print(self.trajectoryIndices)
        &#39;&#39;&#39;


    def getTrajectories(self):

        self.individualTrajectories = []
        for trajCentres in self.centresIndices:
            self.individualTrajectories.append(self.centres[trajCentres])

        self.individualTrajectories = np.array(self.individualTrajectories)
        return self.individualTrajectories

        &#39;&#39;&#39;
        self.individualTrajectories = [ [] for i in range(0, self.maxIndex + 1) ]
        for i in range(0, len(self.trajectoryIndices)):
            for trajIndex in self.trajectoryIndices[i]:
                self.individualTrajectories[trajIndex].append(self.centres[i])

        self.individualTrajectories = np.array(self.individualTrajectories)
        for i in range(len(self.individualTrajectories)):
            if len(self.individualTrajectories[i]) &gt; 0:
                self.individualTrajectories[i] = np.vstack(self.individualTrajectories[i])
        return self.individualTrajectories
        &#39;&#39;&#39;


    def plotTrajectoriesAltAxes(self, ax):
        trajectories = self.getTrajectories()
        for traj in trajectories:
            if len(traj) &gt; 0:
                ax.scatter(traj[:, 3], traj[:, 1], traj[:, 2], marker=&#39;D&#39;, s=10)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pept.tracking.trajectory_separation.trajectory_separation.TrajectorySeparation.find_trajectories"><code class="name flex">
<span>def <span class="ident">find_trajectories</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def find_trajectories(self):

    for i, current_point in enumerate(self.centres):

        if i == 0:
            # Add the first point to trajectory 0
            self.trajectory_indices[0].add(self.max_index)
            self.centres_indices[self.max_index].append(0)
            self.max_index += 1
            continue

        # Search for the closest previous pointsToCheck points
        # within a given maxDistance
        start_index = i - self.points_to_check
        end_index = i

        if start_index &lt; 0:
            start_index = 0

        # Construct a KDTree from the x, y, z (1:4) of the
        # selected points. Get the indices for all the points within
        # maxDistance of the currentPoint
        tree = cKDTree(self.centres[start_index:end_index, 1:4])
        closest_indices = tree.query_ball_point(current_point[1:4],
                                                self.max_distance,
                                                n_jobs = -1)
        closest_indices = np.array(closest_indices) + start_index

        # If no point was found, it is a new trajectory. Continue
        if len(closest_indices) == 0:
            self.trajectory_indices[i].add(self.max_index)
            self.centres_indices.append([i])
            self.max_index += 1
            continue

        # For every close point found, search for all the trajectory indices
        #   - If all trajectory indices sets are equal and of a single value
        #   then currentPoint is part of the same trajectory
        #   - If all trajectory indices sets are equal, but of more values,
        #   then currentPoint diverged from an intersection of trajectories
        #   and is part of a single trajectory =&gt; separate it
        #
        #   - If every pair of trajectory indices sets is not disjoint, then
        #   currentPoint is only one of them
        #   - If there exists a pair of trajectory indices sets that is
        #   disjoint, then currentPoint is part of all of them

        # Select the trajectories of all the points that were found
        # to be the closest
        closest_trajectories = self.trajectory_indices[closest_indices]
        #print(&#34;closestTrajectories:&#34;)
        #print(closestTrajectories)

        # If all the closest points are part of the same trajectory
        # (just one!), then the currentPoint is part of it too
        if (np.all(closest_trajectories == closest_trajectories[0]) and
            len(closest_trajectories[0]) == 1):

            self.trajectory_indices[i] = closest_trajectories[0]
            self.centres_indices[ next(iter(closest_trajectories[0])) ].append(i)
            continue

        # Otherwise, check the points based on their cluster size
        else:
            # Create a list of all the trajectories that were found to
            # intersect
            #print(&#39;\nIntersection:&#39;)
            closest_traj_indices = list( set().union(*closest_trajectories) )

            #print(&#34;ClosestTrajIndices:&#34;)
            #print(closestTrajIndices)

            # For each close trajectory, calculate the mean cluster size
            # of the last points_cluster_size points

            # Keep track of the mean cluster size that is the closest to
            # the currentPoint&#39;s clusterSize
            current_cluster_size = current_point[4]
            #print(&#34;currentClusterSize = {}&#34;.format(currentClusterSize))
            closest_traj_index = -1
            cluster_size_diff = self.max_cluster_size_diff

            for traj_index in closest_traj_indices:
                #print(&#34;trajIndex = {}&#34;.format(trajIndex))

                traj_centres = self.centres[ self.centres_indices[traj_index] ]
                #print(&#34;trajCentres:&#34;)
                #print(trajCentres)
                mean_cluster_size = traj_centres[-self.points_cluster_size:][:, 4].mean()
                #print(&#34;meanClusterSize = {}&#34;.format(meanClusterSize))
                #print(&#34;clusterSizeDiff = {}&#34;.format(clusterSizeDiff))
                #print(&#34;abs diff = {}&#34;.format(np.abs( currentClusterSize - meanClusterSize )))
                if np.abs( current_cluster_size - mean_cluster_size ) &lt; cluster_size_diff:
                    closest_traj_index = traj_index
                    cluster_size_diff = np.abs( current_cluster_size - mean_cluster_size )

            if closest_traj_index == -1:
                #self.trajectoryIndices[i] = set(closestTrajIndices)
                #for trajIndex in closestTrajIndices:
                #    self.centresIndices[trajIndex].append(i)

                print(&#34;\n**** -1 ****\n&#34;)
                break
            else:
                #print(&#34;ClosestTrajIndex found = {}&#34;.format(closestTrajIndex))
                self.trajectory_indices[i] = set([closest_traj_index])
                self.centres_indices[closest_traj_index].append(i)

    individual_trajectories = []
    for traj_centres in self.centres_indices:
        individual_traj = pept.PointData(self.centres[traj_centres],
                                         sample_size = 0,
                                         overlap = 0,
                                         verbose = False)
        individual_trajectories.append(individual_traj)

    return individual_trajectories



    &#39;&#39;&#39;
        # If the current point is not part of any trajectory, assign it
        # the maxIndex and increment it
        if len(self.trajectoryIndices[i]) == 0:
            self.trajectoryIndices[i].append(self.maxIndex)
            self.maxIndex += 1

        print(self.trajectoryIndices[i])
        print(self.maxIndex)

        # Construct a KDTree from the numberOfPoints in front of
        # the current point
        tree = cKDTree(self.trajectory[(i + 1):(i + self.numberOfPoints + 2)][1:4])

        # For every trajectory that the current point is part of,
        # find the closest points in front of it
        numberOfIntersections = len(self.trajectoryIndices[i])
        dist, nextPointsIndices = tree.query(currentPoint, k=numberOfIntersections, distance_upper_bound=self.maxDistance, n_jobs=-1)

        print(nextPointsIndices)

        # If the current point is part of more trajectories,
        # an intersection happened. Call subroutine to part
        # the trajectories
        if numberOfIntersections &gt; 1:
            for j in range(0, len(self.trajectoryIndices[i])):
                trajIndex = self.trajectoryIndices[i][j]
                self.trajectoryIndices[i + 1 + nextPointsIndices[j]].append(trajIndex)

        else:
            self.trajectoryIndices[i + 1 + nextPointsIndices].append(self.trajectoryIndices[i][0])

        print(self.trajectoryIndices)
    &#39;&#39;&#39;</code></pre>
</details>
</dd>
<dt id="pept.tracking.trajectory_separation.trajectory_separation.TrajectorySeparation.getTrajectories"><code class="name flex">
<span>def <span class="ident">getTrajectories</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getTrajectories(self):

    self.individualTrajectories = []
    for trajCentres in self.centresIndices:
        self.individualTrajectories.append(self.centres[trajCentres])

    self.individualTrajectories = np.array(self.individualTrajectories)
    return self.individualTrajectories

    &#39;&#39;&#39;
    self.individualTrajectories = [ [] for i in range(0, self.maxIndex + 1) ]
    for i in range(0, len(self.trajectoryIndices)):
        for trajIndex in self.trajectoryIndices[i]:
            self.individualTrajectories[trajIndex].append(self.centres[i])

    self.individualTrajectories = np.array(self.individualTrajectories)
    for i in range(len(self.individualTrajectories)):
        if len(self.individualTrajectories[i]) &gt; 0:
            self.individualTrajectories[i] = np.vstack(self.individualTrajectories[i])
    return self.individualTrajectories
    &#39;&#39;&#39;</code></pre>
</details>
</dd>
<dt id="pept.tracking.trajectory_separation.trajectory_separation.TrajectorySeparation.plotTrajectoriesAltAxes"><code class="name flex">
<span>def <span class="ident">plotTrajectoriesAltAxes</span></span>(<span>self, ax)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def plotTrajectoriesAltAxes(self, ax):
    trajectories = self.getTrajectories()
    for traj in trajectories:
        if len(traj) &gt; 0:
            ax.scatter(traj[:, 3], traj[:, 1], traj[:, 2], marker=&#39;D&#39;, s=10)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pept.tracking.trajectory_separation" href="index.html">pept.tracking.trajectory_separation</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pept.tracking.trajectory_separation.trajectory_separation.findMeanError" href="#pept.tracking.trajectory_separation.trajectory_separation.findMeanError">findMeanError</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pept.tracking.trajectory_separation.trajectory_separation.TrajectorySeparation" href="#pept.tracking.trajectory_separation.trajectory_separation.TrajectorySeparation">TrajectorySeparation</a></code></h4>
<ul class="">
<li><code><a title="pept.tracking.trajectory_separation.trajectory_separation.TrajectorySeparation.find_trajectories" href="#pept.tracking.trajectory_separation.trajectory_separation.TrajectorySeparation.find_trajectories">find_trajectories</a></code></li>
<li><code><a title="pept.tracking.trajectory_separation.trajectory_separation.TrajectorySeparation.getTrajectories" href="#pept.tracking.trajectory_separation.trajectory_separation.TrajectorySeparation.getTrajectories">getTrajectories</a></code></li>
<li><code><a title="pept.tracking.trajectory_separation.trajectory_separation.TrajectorySeparation.plotTrajectoriesAltAxes" href="#pept.tracking.trajectory_separation.trajectory_separation.TrajectorySeparation.plotTrajectoriesAltAxes">plotTrajectoriesAltAxes</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>